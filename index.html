<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Puck.js Live Recorder</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg-a: #f7f2e6;
      --bg-b: #d8e8de;
      --card: rgba(255, 255, 255, 0.88);
      --text: #202728;
      --muted: #4d6264;
      --line: rgba(32, 39, 40, 0.16);
      --accent: #0f8d78;
      --accent-alt: #e17b3f;
      --danger: #a53030;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Space Grotesk", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 10% 0%, rgba(15, 141, 120, 0.16), transparent 55%),
        radial-gradient(circle at 90% 100%, rgba(225, 123, 63, 0.2), transparent 50%),
        linear-gradient(135deg, var(--bg-a), var(--bg-b));
      padding: 18px;
    }

    .page {
      max-width: 1160px;
      margin: 0 auto;
      animation: rise-in 280ms ease-out;
    }

    @keyframes rise-in {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .top {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.4rem, 3vw, 1.9rem);
      line-height: 1.15;
      letter-spacing: 0.02em;
    }

    .sub {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button {
      border: 0;
      border-radius: 12px;
      padding: 10px 14px;
      font: inherit;
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, opacity 120ms ease;
    }

    button:hover:enabled {
      transform: translateY(-1px);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn-main {
      background: var(--accent);
      color: #fff;
    }

    .btn-secondary {
      background: #e8eee9;
      color: var(--text);
    }

    .btn-danger {
      background: #f2dede;
      color: var(--danger);
    }

    .status {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 18px;
      font-size: 0.95rem;
    }

    .status strong {
      color: var(--accent);
    }

    .warning {
      color: var(--danger);
      margin: 0;
      font-size: 0.9rem;
    }

    .grid {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 12px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      backdrop-filter: blur(4px);
    }

    .card h2 {
      margin: 0 0 10px;
      font-size: 1rem;
      letter-spacing: 0.02em;
    }

    .canvas-wrap {
      height: 230px;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .log-wrap {
      margin-top: 14px;
      background: #152124;
      color: #cce8dd;
      border-radius: 14px;
      border: 1px solid rgba(21, 33, 36, 0.5);
      padding: 12px;
    }

    .log-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      color: #e8f3ef;
      font-size: 0.92rem;
    }

    pre {
      margin: 0;
      max-height: 220px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.82rem;
      line-height: 1.45;
    }

    @media (max-width: 640px) {
      body {
        padding: 12px;
      }

      .top {
        padding: 12px;
      }

      .canvas-wrap {
        height: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <section class="top">
      <div>
        <h1>Puck.js Live Recorder</h1>
        <p class="sub">Connect over Bluetooth, stream sensor/button output, and plot each signal on its own chart.</p>
      </div>
      <div class="controls">
        <button id="connectBtn" class="btn-main">Connect Puck.js</button>
        <button id="stopBtn" class="btn-danger" disabled>Stop Stream</button>
        <button id="downloadBtn" class="btn-secondary" disabled>Download JSON</button>
        <button id="clearBtn" class="btn-secondary">Clear Charts + Log</button>
      </div>
      <div class="status">
        <div>Status: <strong id="statusText">Idle</strong></div>
        <div>Samples: <strong id="sampleCount">0</strong></div>
        <div>Button: <strong id="buttonState">Unknown</strong></div>
      </div>
      <p id="secureWarning" class="warning" hidden>Web Bluetooth requires a secure context. Use <code>https://</code> or <code>http://localhost</code> (or <code>http://127.0.0.1</code>). Plain <code>http://</code> on LAN IPs and <code>file://</code> are blocked.</p>
    </section>

    <section class="grid">
      <article class="card">
        <h2>Accelerometer (x/y/z)</h2>
        <div class="canvas-wrap"><canvas id="accelChart"></canvas></div>
      </article>
      <article class="card">
        <h2>Gyroscope (x/y/z)</h2>
        <div class="canvas-wrap"><canvas id="gyroChart"></canvas></div>
      </article>
      <article class="card">
        <h2>Magnetometer (x/y/z)</h2>
        <div class="canvas-wrap"><canvas id="magChart"></canvas></div>
      </article>
      <article class="card">
        <h2>Button (0/1)</h2>
        <div class="canvas-wrap"><canvas id="buttonChart"></canvas></div>
      </article>
    </section>

    <section class="log-wrap">
      <div class="log-head">
        <span>Raw Puck Output</span>
        <span id="logCount">0 lines</span>
      </div>
      <pre id="log"></pre>
    </section>
  </div>

  <script>
    const NUS_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
    const NUS_RX_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
    const NUS_TX_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
    const CHART_WINDOW_MS = 10000;
    const MAX_POINTS = 2000;

    const ui = {
      connectBtn: document.getElementById("connectBtn"),
      stopBtn: document.getElementById("stopBtn"),
      clearBtn: document.getElementById("clearBtn"),
      downloadBtn: document.getElementById("downloadBtn"),
      statusText: document.getElementById("statusText"),
      sampleCount: document.getElementById("sampleCount"),
      buttonState: document.getElementById("buttonState"),
      log: document.getElementById("log"),
      logCount: document.getElementById("logCount"),
      secureWarning: document.getElementById("secureWarning")
    };

    const state = {
      device: null,
      server: null,
      rxChar: null,
      txChar: null,
      lineBuffer: "",
      sampleNumber: 0,
      logLines: 0,
      recorded: [],
      lastButton: null,
      chartOriginMs: null
    };

    const textDecoder = new TextDecoder();
    const textEncoder = new TextEncoder();

    function chartBaseOptions() {
      return {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        normalized: true,
        plugins: {
          legend: {
            labels: {
              usePointStyle: true,
              boxWidth: 8
            }
          }
        },
        scales: {
          x: {
            ticks: { maxTicksLimit: 6 },
            grid: { color: "rgba(0,0,0,0.06)" }
          },
          y: {
            grid: { color: "rgba(0,0,0,0.08)" }
          }
        }
      };
    }

    function makeVectorChart(canvasId, yTitle) {
      return new Chart(document.getElementById(canvasId), {
        type: "line",
        data: {
          labels: [],
          datasets: [
            { label: "x", data: [], borderColor: "#0f8d78", backgroundColor: "#0f8d78", pointRadius: 0, borderWidth: 1.8, tension: 0.18 },
            { label: "y", data: [], borderColor: "#e17b3f", backgroundColor: "#e17b3f", pointRadius: 0, borderWidth: 1.8, tension: 0.18 },
            { label: "z", data: [], borderColor: "#0f5ca8", backgroundColor: "#0f5ca8", pointRadius: 0, borderWidth: 1.8, tension: 0.18 }
          ]
        },
        options: {
          ...chartBaseOptions(),
          scales: {
            ...chartBaseOptions().scales,
            y: {
              ...chartBaseOptions().scales.y,
              title: { display: true, text: yTitle }
            }
          }
        }
      });
    }

    function makeButtonChart() {
      return new Chart(document.getElementById("buttonChart"), {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "BTN",
              data: [],
              borderColor: "#a53030",
              backgroundColor: "#a53030",
              pointRadius: 0,
              borderWidth: 2,
              stepped: true
            }
          ]
        },
        options: {
          ...chartBaseOptions(),
          scales: {
            ...chartBaseOptions().scales,
            y: {
              min: -0.1,
              max: 1.1,
              ticks: { stepSize: 1 },
              title: { display: true, text: "off/on" },
              grid: { color: "rgba(0,0,0,0.08)" }
            }
          }
        }
      });
    }

    const charts = {
      accel: makeVectorChart("accelChart", "g"),
      gyro: makeVectorChart("gyroChart", "deg/s"),
      mag: makeVectorChart("magChart", "uT"),
      button: makeButtonChart()
    };

    function setStatus(text) {
      ui.statusText.textContent = text;
    }

    function updateButtonState(value) {
      if (value === null || value === undefined) {
        ui.buttonState.textContent = "Unknown";
        return;
      }
      ui.buttonState.textContent = value ? "On" : "Off";
    }

    function appendLog(line) {
      state.logLines += 1;
      ui.logCount.textContent = state.logLines + " lines";
      ui.log.textContent += line + "\n";
      if (ui.log.textContent.length > 40000) {
        ui.log.textContent = ui.log.textContent.slice(-35000);
      }
      ui.log.scrollTop = ui.log.scrollHeight;
    }

    function ensureChartTimes(chart) {
      if (!Array.isArray(chart._timesMs)) {
        chart._timesMs = [];
      }
      return chart._timesMs;
    }

    function shiftChartPoint(chart, times) {
      chart.data.labels.shift();
      chart.data.datasets.forEach((ds) => ds.data.shift());
      times.shift();
    }

    function trimChart(chart, newestTimeMs) {
      const times = ensureChartTimes(chart);
      while (chart.data.labels.length > MAX_POINTS && times.length) {
        shiftChartPoint(chart, times);
      }
      while (times.length && newestTimeMs - times[0] > CHART_WINDOW_MS) {
        shiftChartPoint(chart, times);
      }
    }

    function toFiniteNumber(value) {
      const numeric = typeof value === "number" ? value : Number(value);
      return Number.isFinite(numeric) ? numeric : null;
    }

    function vectorAxis(vector, axis) {
      if (Array.isArray(vector)) {
        const idx = axis === "x" ? 0 : axis === "y" ? 1 : 2;
        return toFiniteNumber(vector[idx]);
      }
      if (!vector || typeof vector !== "object") return null;
      const direct = toFiniteNumber(vector[axis]);
      if (direct !== null) return direct;
      return toFiniteNumber(vector[axis.toUpperCase()]);
    }

    function formatElapsedLabel(timeMs) {
      if (!Number.isFinite(state.chartOriginMs)) {
        state.chartOriginMs = timeMs;
      }
      return ((timeMs - state.chartOriginMs) / 1000).toFixed(1) + "s";
    }

    function pushVector(chart, label, vector, timeMs) {
      const times = ensureChartTimes(chart);
      chart.data.labels.push(label);
      times.push(timeMs);
      chart.data.datasets[0].data.push(vectorAxis(vector, "x"));
      chart.data.datasets[1].data.push(vectorAxis(vector, "y"));
      chart.data.datasets[2].data.push(vectorAxis(vector, "z"));
      trimChart(chart, timeMs);
      chart.update("none");
    }

    function pushButton(label, value, timeMs) {
      const times = ensureChartTimes(charts.button);
      charts.button.data.labels.push(label);
      times.push(timeMs);
      charts.button.data.datasets[0].data.push(value ? 1 : 0);
      trimChart(charts.button, timeMs);
      charts.button.update("none");
      state.lastButton = value ? 1 : 0;
      updateButtonState(state.lastButton);
    }

    function clearAll() {
      Object.values(charts).forEach((chart) => {
        chart.data.labels = [];
        chart.data.datasets.forEach((ds) => { ds.data = []; });
        chart._timesMs = [];
        chart.update();
      });
      state.sampleNumber = 0;
      state.recorded = [];
      state.logLines = 0;
      state.lastButton = null;
      state.chartOriginMs = null;
      ui.sampleCount.textContent = "0";
      ui.logCount.textContent = "0 lines";
      ui.log.textContent = "";
      updateButtonState(null);
      ui.downloadBtn.disabled = true;
    }

    function toMsTime(anyTime) {
      if (!Number.isFinite(anyTime)) return Date.now();
      if (anyTime > 1000000000000) return anyTime;
      return Math.round(anyTime * 1000);
    }

    function toChartTimeMs() {
      return Date.now();
    }

    function extractJsonFragments(line) {
      const out = [];
      let start = -1;
      let depth = 0;
      let inString = false;
      let escaping = false;

      for (let i = 0; i < line.length; i += 1) {
        const ch = line[i];
        if (start < 0) {
          if (ch === "{") {
            start = i;
            depth = 1;
            inString = false;
            escaping = false;
          }
          continue;
        }

        if (inString) {
          if (escaping) {
            escaping = false;
          } else if (ch === "\\") {
            escaping = true;
          } else if (ch === "\"") {
            inString = false;
          }
          continue;
        }

        if (ch === "\"") {
          inString = true;
        } else if (ch === "{") {
          depth += 1;
        } else if (ch === "}") {
          depth -= 1;
          if (depth === 0) {
            out.push(line.slice(start, i + 1));
            start = -1;
          }
        }
      }

      return out;
    }

    function extractFirstObjectForKey(fragment, key) {
      const token = "\"" + key + "\"";
      let cursor = 0;

      while (cursor < fragment.length) {
        const keyIndex = fragment.indexOf(token, cursor);
        if (keyIndex < 0) return null;

        let i = keyIndex + token.length;
        while (i < fragment.length && /\s/.test(fragment[i])) i += 1;
        if (fragment[i] !== ":") {
          cursor = keyIndex + token.length;
          continue;
        }
        i += 1;
        while (i < fragment.length && /\s/.test(fragment[i])) i += 1;
        if (fragment[i] !== "{") {
          cursor = keyIndex + token.length;
          continue;
        }

        let depth = 0;
        let inString = false;
        let escaping = false;
        for (let j = i; j < fragment.length; j += 1) {
          const ch = fragment[j];
          if (inString) {
            if (escaping) {
              escaping = false;
            } else if (ch === "\\") {
              escaping = true;
            } else if (ch === "\"") {
              inString = false;
            }
            continue;
          }

          if (ch === "\"") {
            inString = true;
          } else if (ch === "{") {
            depth += 1;
          } else if (ch === "}") {
            depth -= 1;
            if (depth === 0) {
              const candidate = fragment.slice(i, j + 1);
              try {
                return JSON.parse(candidate);
              } catch (_) {
                return null;
              }
            }
          }
        }

        return null;
      }

      return null;
    }

    function vectorHasFiniteAxis(vector) {
      return (
        vectorAxis(vector, "x") !== null ||
        vectorAxis(vector, "y") !== null ||
        vectorAxis(vector, "z") !== null
      );
    }

    function pickBestVector(msg, fragment, keys) {
      for (const key of keys) {
        const candidate = msg[key];
        if (candidate !== null && candidate !== undefined && vectorHasFiniteAxis(candidate)) {
          return candidate;
        }
      }

      for (const key of keys) {
        const recovered = extractFirstObjectForKey(fragment, key);
        if (recovered !== null && recovered !== undefined && vectorHasFiniteAxis(recovered)) {
          return recovered;
        }
      }

      for (const key of keys) {
        if (msg[key] !== undefined) return msg[key];
      }

      return null;
    }

    function normalizeSampleVectorsFromRaw(fragment, msg) {
      if (!msg || typeof msg !== "object" || msg.type !== "sample") return msg;

      return {
        ...msg,
        accel: pickBestVector(msg, fragment, ["accel", "acc", "accelerometer", "a"]),
        gyro: pickBestVector(msg, fragment, ["gyro", "gyr", "gyroscope", "g"]),
        mag: pickBestVector(msg, fragment, ["mag", "magnetometer", "m"])
      };
    }

    function processLine(line) {
      const fragments = extractJsonFragments(line);
      for (const fragment of fragments) {
        try {
          const parsed = JSON.parse(fragment);
          processData(normalizeSampleVectorsFromRaw(fragment, parsed));
        } catch (_) {
          // Keep raw line visible even if JSON parsing fails.
        }
      }
    }

    function processData(msg) {
      const msgType = msg && typeof msg === "object" ? msg.type : "";
      if (msgType === "sample") {
        state.sampleNumber += 1;
        const chartTimeMs = toChartTimeMs(msg);
        const label = formatElapsedLabel(chartTimeMs);
        pushVector(charts.accel, label, msg.accel, chartTimeMs);
        pushVector(charts.gyro, label, msg.gyro, chartTimeMs);
        pushVector(charts.mag, label, msg.mag, chartTimeMs);
        if (msg.button !== undefined) {
          pushButton(label, msg.button, chartTimeMs);
        } else if (state.lastButton !== null) {
          pushButton(label, state.lastButton, chartTimeMs);
        }
        state.recorded.push({
          localTimeMs: Date.now(),
          puckTimeMs: toMsTime(msg.time),
          ...msg
        });
        ui.sampleCount.textContent = String(state.sampleNumber);
        ui.downloadBtn.disabled = state.recorded.length === 0;
        return;
      }

      if (msgType === "button") {
        const chartTimeMs = toChartTimeMs(msg);
        const label = formatElapsedLabel(chartTimeMs);
        pushButton(label, msg.value, chartTimeMs);
        state.recorded.push({
          localTimeMs: Date.now(),
          puckTimeMs: toMsTime(msg.time),
          ...msg
        });
        ui.downloadBtn.disabled = state.recorded.length === 0;
        return;
      }

      if (msgType === "status") {
        if (msg.message === "wario-stream-started" && msg.gyroAvailable === false) {
          appendLog("[info] No gyroscope API exposed by this Puck firmware/hardware. Gyro chart will stay empty.");
        }
        if (msg.message === "wario-stream-started" && msg.accelAvailable === false) {
          appendLog("[info] No accelerometer API exposed by this Puck firmware/hardware. Accelerometer chart will stay empty.");
        }
        return;
      }
    }

    function handleIncomingText(text) {
      state.lineBuffer += text;
      let newlineIndex = state.lineBuffer.indexOf("\n");
      while (newlineIndex >= 0) {
        const line = state.lineBuffer.slice(0, newlineIndex).trim();
        state.lineBuffer = state.lineBuffer.slice(newlineIndex + 1);
        if (line.length > 0) {
          appendLog(line);
          processLine(line);
        }
        newlineIndex = state.lineBuffer.indexOf("\n");
      }
    }

    function onNotification(event) {
      const text = textDecoder.decode(event.target.value);
      handleIncomingText(text);
    }

    async function writeToRx(text) {
      const bytes = textEncoder.encode(text);
      const chunkSize = 20;
      const writer = state.rxChar.writeValueWithoutResponse
        ? state.rxChar.writeValueWithoutResponse.bind(state.rxChar)
        : state.rxChar.writeValue.bind(state.rxChar);
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        await writer(chunk);
        await new Promise((resolve) => setTimeout(resolve, 12));
      }
    }

    async function uploadStreamScript() {
      const script = [
        "\u0003",
        "if (global.__warioI) clearInterval(global.__warioI);",
        "if (global.__warioW) clearWatch(global.__warioW);",
        "if (Puck.accelOn) Puck.accelOn();",
        "if (Puck.magOn) Puck.magOn();",
        "function __warioSample(){",
        "  var a = (Puck.accel) ? Puck.accel() : null;",
        "  var g = (Puck.gyro) ? Puck.gyro() : null;",
        "  var m = (Puck.mag) ? Puck.mag() : null;",
        "  print(JSON.stringify({type:'sample',time:getTime(),accel:a,gyro:g,mag:m,button:digitalRead(BTN)?1:0}));",
        "}",
        "global.__warioW = setWatch(function(){",
        "  print(JSON.stringify({type:'button',time:getTime(),value:digitalRead(BTN)?1:0}));",
        "}, BTN, {repeat:true,edge:'both',debounce:20});",
        "global.__warioI = setInterval(__warioSample, 100);",
        "print(JSON.stringify({type:'status',time:getTime(),message:'wario-stream-started',gyroAvailable:!!Puck.gyro,accelAvailable:!!Puck.accel,magAvailable:!!Puck.mag}));"
      ].join("\n") + "\n";
      await writeToRx(script);
    }

    async function stopStreamScript() {
      if (!state.rxChar) return;
      const stopScript = [
        "\u0003",
        "if (global.__warioI) { clearInterval(global.__warioI); global.__warioI = undefined; }",
        "if (global.__warioW) { clearWatch(global.__warioW); global.__warioW = undefined; }",
        "print(JSON.stringify({type:'status',time:getTime(),message:'wario-stream-stopped'}));"
      ].join("\n") + "\n";
      await writeToRx(stopScript);
    }

    function setConnectedUi(connected) {
      ui.connectBtn.disabled = connected;
      ui.stopBtn.disabled = !connected;
    }

    async function requestPuckDevice() {
      const strictOptions = {
        filters: [
          { namePrefix: "Puck.js" },
          { services: [NUS_SERVICE_UUID] }
        ],
        optionalServices: [NUS_SERVICE_UUID]
      };

      try {
        return await navigator.bluetooth.requestDevice(strictOptions);
      } catch (err) {
        if (err && err.name === "NotFoundError") {
          appendLog("[warn] No Puck.js-specific match found. Opening full Bluetooth chooser.");
          return navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: [NUS_SERVICE_UUID]
          });
        }
        throw err;
      }
    }

    async function connectPuck() {
      if (!window.isSecureContext) {
        setStatus("Blocked: use HTTPS or localhost");
        appendLog("[error] Insecure origin. Open this page on https:// or http://localhost.");
        return;
      }
      if (!("bluetooth" in navigator)) {
        setStatus("Web Bluetooth unsupported");
        appendLog("[error] Use a Web Bluetooth browser (Chrome/Edge) on a supported OS.");
        return;
      }
      ui.connectBtn.disabled = true;
      setStatus("Requesting device...");
      try {
        state.device = await requestPuckDevice();
        state.device.addEventListener("gattserverdisconnected", onDisconnected);
        state.server = await state.device.gatt.connect();
        const service = await state.server.getPrimaryService(NUS_SERVICE_UUID);
        state.rxChar = await service.getCharacteristic(NUS_RX_UUID);
        state.txChar = await service.getCharacteristic(NUS_TX_UUID);
        state.txChar.addEventListener("characteristicvaluechanged", onNotification);
        await state.txChar.startNotifications();
        setStatus("Connected to " + (state.device.name || "Puck.js"));
        await uploadStreamScript();
        appendLog("[info] Streaming started.");
        setConnectedUi(true);
      } catch (err) {
        if (err && err.name === "NotFoundError") {
          setStatus("No device selected");
          appendLog("[warn] Bluetooth chooser closed or no matching device selected.");
        } else {
          setStatus("Connection failed");
          appendLog("[error] " + (err && err.message ? err.message : String(err)));
        }
        setConnectedUi(false);
      }
    }

    async function disconnectPuck() {
      try {
        await stopStreamScript();
      } catch (err) {
        appendLog("[warn] Could not send stop command: " + (err && err.message ? err.message : String(err)));
      }
      if (state.device && state.device.gatt && state.device.gatt.connected) {
        state.device.gatt.disconnect();
      }
      onDisconnected();
    }

    function onDisconnected() {
      if (state.txChar) {
        state.txChar.removeEventListener("characteristicvaluechanged", onNotification);
      }
      state.server = null;
      state.rxChar = null;
      state.txChar = null;
      state.lineBuffer = "";
      setStatus("Disconnected");
      appendLog("[info] Disconnected.");
      setConnectedUi(false);
    }

    function downloadJson() {
      if (!state.recorded.length) return;
      const payload = {
        exportedAt: new Date().toISOString(),
        count: state.recorded.length,
        records: state.recorded
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "puck-recording-" + new Date().toISOString().replace(/[:.]/g, "-") + ".json";
      a.click();
      URL.revokeObjectURL(url);
    }

    ui.connectBtn.addEventListener("click", connectPuck);
    ui.stopBtn.addEventListener("click", disconnectPuck);
    ui.clearBtn.addEventListener("click", clearAll);
    ui.downloadBtn.addEventListener("click", downloadJson);

    if (!window.isSecureContext) {
      ui.secureWarning.hidden = false;
    }
  </script>
</body>
</html>
